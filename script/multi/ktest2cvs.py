#!/usr/bin/env python

'''
Python script for converting test cases generated by Klee to csv file format
Usage: ./ktest2cvs.py [path/to/klee-last]
'''

import os
import sys
import glob

sys.path.append('multi/disassembler/or1k/')
from disassembler import disassemble

DECODE_ENABLE = 1
CONVERT_ERR_ONLY = 1
WRITE_TO_FILE = 1

if (len(sys.argv) != 2):
    print "Usage: ./ktest2cvs.py [path/to/klee-last]"
    sys.exit()

kleelast_path = str(sys.argv[1])
target = open("testcases.csv", 'w')
if os.path.exists("instructions.txt"):
    append_write = 'a'
else:
    append_write = 'w'
decode = open("instructions.txt", append_write)

first = True
dinsn = False
opcodeSet = {}
for filename in glob.glob(os.path.join(kleelast_path, '*.ktest')):
    if CONVERT_ERR_ONLY:
        errfilename = filename.replace("ktest", "assert.err")
        if (os.path.isfile(errfilename) == False):
            continue
    os.system('ktest-tool --write-ints '+ filename + ' > result.txt')
    # print column names
    if (first == True):
        first = False
        with open("result.txt") as f:
            content = f.readlines()
            lastsym = content[-1].replace("\n", "").split(": ")[0]
            if WRITE_TO_FILE:
                target.write("test_no" + ',')
            for c in content:
                line = c.replace("\n", "")
                parts = line.split(": ")
                if (len(parts) == 3 and parts[1] == 'name'):
                    if (parts[0] == lastsym):
                        if WRITE_TO_FILE: 
                            target.write(str(parts[2].replace("'", "")))
                    else:
                        if WRITE_TO_FILE: 
                            target.write(str(parts[2].replace("'", "")) + ",")
        if WRITE_TO_FILE: 
            target.write("\n")
        f.close()
                    
    with open("result.txt") as f:
        content = f.readlines()
        for c in content:
            line = c.replace("\n", "")
            parts = line.split(": ")
            if (len(parts) == 2 and parts[0] == 'ktest file '):
                parts[1] = parts[1].replace("'", "").split("/")[-1].split(".")[0]
                print "Converting " + parts[1] + "..."
                if WRITE_TO_FILE: 
                    target.write(str(parts[1]) + ',')
                if (DECODE_ENABLE):
                    if WRITE_TO_FILE: 
                        decode.write(str(parts[1]) + '\n')
            if (len(parts) == 3 and parts[1] == 'data'):
                if (c == content[-1]):
                    if WRITE_TO_FILE: 
                        target.write(str(parts[2]))
                else:
                    if WRITE_TO_FILE: 
                        target.write(str(parts[2]) + ',')
                    # decode instructions
                    if (DECODE_ENABLE and dinsn):
                        if WRITE_TO_FILE: 
                            decode.write('{0: <12}'.format(str(parts[2]))+': ')
                        insnlist = disassemble(hex(int(parts[2])))
                        if (insnlist[0] == 'unknown'):
                            print hex(int(parts[2]))
                            quit()
                        for i in insnlist:
                            if WRITE_TO_FILE: 
                                decode.write(i+' ')
                        if insnlist[0] not in opcodeSet:
                            opcodeSet[insnlist[0]] = 1
                        else:
                            opcodeSet[insnlist[0]] += 1
                        if WRITE_TO_FILE: 
                            decode.write('\n')
                        dinsn = False
            if (DECODE_ENABLE):
                if (len(parts) == 3 and str(parts[2]).find('icpu_dat_i') != -1):
                    dinsn = True
#                if (len(parts) == 3 and str(parts[2]).find('icpu_dat_i_2') != -1):
#                    dinsn = True

    if WRITE_TO_FILE: 
        target.write("\n")
    f.close()

target.close()

if (DECODE_ENABLE): 
    print 'There are '+str(len(opcodeSet))+' opcodes.'
    for opcode in opcodeSet:
        print opcode+' '+str(opcodeSet[opcode])


decode.close()
os.system('rm result.txt')
